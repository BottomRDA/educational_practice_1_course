ТЕСТИРОВАНИЕ ПРОГРАММ

Каждый из вас, конечно, слышал высказывание о том, что «В каждой программе есть, по крайней мере, одна ошибка». Каким бы странным ни казалось это высказывание из программистского фольклора, но в нем есть очень большая доля истины, конечно, если речь идет не об элементарной учебной программе, а о каком-то настоящем программном продукте. Чем длиннее и сложнее программа, тем менее мы можем быть уверены в том, что она работает правильно во всех случаях. Вопрос о том, как показать (или доказать), что программа «правильная», давно стал предметом изучения. Он волнует как создателей программ, так и их пользователей. Правильная программа не только должна делать то, для чего она предназначена, но и не должна делать того, что от нее не требуется. Хуже всего, если программа на неправильные данные выдает правдоподобные результаты. Обсудим некоторые вопросы, связанные с одним из видов проверки правильности программ - тестированием, и некоторые технологии тестирования, которые для этого применяются.

С начала 50-х годов, когда начали составляться первые программы, и до наших дней отмечен огромный рост стоимости программных продуктов. И если до начала 70-х годов в оценке труда программиста наблюдался явный оптимизм (была бы хорошая техническая база, вот тогда мы сможем решить все проблемы), то с начала 70-х годов все явственнее стал проявляться кризис, который затронул и область научных исследований, и производство. Этот кризис был обусловлен как усложнением программ, решающих реальные производственные задачи, так и уменьшением надежности этих

программ. Появились уже не слухи, а статьи и официальные сообщения о «провалах» проектов, произошедших не из-за сбоя оборудования, а из-за ошибки программиста. Так из-за одной ошибки в программе на Фортране потерпела неудачу попытка запуска первого исследовательского американского корабля на Венеру, произошло несколько смертей в медицинских учреждениях, несколько авиакатастроф.

Вследствие этого встал вопрос о том, что нужно что-то менять в самом программировании. Эдсгер Дейкстра первым взглянул на программу не с точки зрения затрат времени и памяти, а обратил внимание на то, как программа написана, то есть на текст программы и действия, которые этот текст вызывает. Так появилось теоретическое направление в программировании и такое важное понятие как структурное программирование (structured programming). В структурном программировании параллельно рассматриваются два вопроса:

- как организовать работу над программой,

- как организовать документацию.

Оказалось, что при использовании

структурного программирования можно решить многие проблемы:

- повышается в 5 раз производительность труда программиста;

W клффш праграмме ес&ь, па крайней мере, о<иибка,

- повышается ясность и читабельность программ;

- меньше требуется вносить изменений в уже созданную программу, а многочисленные исследования показали, что стоимость проверки на правильность одного изменения, внесенного в программу, в 100 раз выше, чем стоимость самого изменения;

- легче тестировать и документировать программы, а стоимость сопровождения программы экспоненциальна по отношению к длине программы. Если учесть, что программы постоянно усложняются и становятся все более длинными, то необходимость использования принципов структурного программирования становится очевидной. Большие программы, предназначенные для коммерческих целей или длительной эксплуатации многими пользователями принято называть программными продуктами.

Прежде всего необходимо разобраться в том, что такое тестирование и чем термин «тестирование программ» отличается от термина «отладка программ». Ясно, что и отладка, и тестирование - это некоторые мероприятия, которые проводятся для повышения надежности программного продукта. Несмотря на то, что проблема определения правильности программ стоит уже давно и ею занимались и продолжают заниматься многие ученые, до сих пор на вопрос, что какое тестирование можно услышать утверждение, что «тестирование - это процесс, подтверждающий правильность программы и демонстрирующий, что ошибок в программе нет». Однако любой человек, занимающийся программированием, знает, что продемонстрировать полное отсутствие ошибок в программе невозможно. Такое «определение» тестирования описывает что-то противоположное тому, что на самом деле следует понимать под термином «тестирование». С таким ошибочным представлением пытались бороться почти все классики программирования. Например, Николас Вирт писал «Экспериментальное тестирование программ может служить для доказательства наличия ошибок, но никог-

да не докажет их отсутствия». Большой специалист по тестированию Гленфорд Майерс дает такое определение:

Тестирование - процесс выполнения программы с целью найти ошибки.

Тестирование процесс довольно необычный, а поэтому и трудный. Это процесс деструктивный (разрушительный), ведь цель тестировщика (иногда говорят «тестовика») - заставить программу сбиться, проработать неправильно. Трудность тестирования во многом психологическая. Тест считается успешным, если выявлена хотя бы одна ошибка. Однако, если программист сам составляет тесты для своих программ, то он подсознательно хочет показать, что его программа верна, поэтому его тесты с большой вероятностью будут выполняться правильно, «хитрые» тесты подсознательно будут блокироваться. Академик Андрей Петрович Ершов писал: «Слабый профессионализм большинства программистов затрудняет им преодоление наивного оптимизма в самооценке своего труда, при котором предусмотрительное ожидание ошибки постоянно заслоняется верой в близость конечной цели».

Из всего сказанного, следуя Г. Май-ерсу, сделаем основной вывод:

«Если ваша цель - показать отсутствие ошибок, вы их найдете не слишком много. Если же ваша цель -показать наличие ошибок, вы найдете значительную их часть».

В последние годы принято, чтобы при создании крупных программных продуктов тестирование проводил не сам программист, а специальная группа тестиров-щиков. При обнаружении ошибки тести-

Эйо процесс дес&рфайи&Ямй (рг^Ьфии&емЖмй)...

?сли фе цель — аокауг&ь Наличие ошибок.

Найдойе ^Наги^йел-йН^^о их гас&ь,

ровщик информирует программиста, тот исправляет ее и вновь программа тестируется. Этот процесс последовательного поиска и исправления ошибок называется отладкой программ. Если программа правильно ведет себя для солидного набора тестов, то хоть и нельзя утверждать, что она работает правильно всегда, но можно говорить, что неизвестно, когда она работает неправильно, и о некотором уровне уверенности в правильности программы.

Возникает вопрос, нельзя ли так составить наборы тестов, чтобы рассмотреть все возможные значения переменных, с которыми работает программа, и пройти по всем возможным путям, предусмотренным в программе?

К сожалению, такой подход совершенно неосуществим даже для самых простых программ.

Для доказательства невозможности перебрать все наборы допустимых данных, рассмотрим простой пример, предложенный Г. Майерсом.

Даны четыре целых числа. Требуется найти их среднее арифметическое. В результате работы такой программы должно получиться одно вещественное число. Как известно, на хранение одного целого числа отводится 2 байта или 16 бит. Таким образом, чтобы перебрать все возможные целые числа для тестирования этой программы, потребуется для одной переменной рассмотреть 216 вариантов значений. Следовательно, для четы-

рех переменных вариантов будет 216 *216 *216 *216 = 264. Если предположить, что программа исполняется 0,001 сек, то на исчерпывающее тестирование этой программы потребуется около 585 млн. лет.

Аналогичная картина будет и при проверке всех переходов в программе.

Даже, если предположить, что мы когда-то сумеем провести исчерпывающее тестирование программы, , то и тогда мы не сможем быть уверены в абсолютной правильности этой программы, так как, возможно, мы построили неправильный алгоритм ее решения. Например, если при поиске корня кубического из числа, мы воспользовались формулами, извлекающими корень квадратный, то программа не будет правильной, даже если мы проверим все выполнимые пути.

Отсюда следует основной вывод: исчерпывающее тестирование невозможно.

Теперь рассмотрим относительную стоимость разработки программных продуктов на разных стадиях разработки.

Для относительно небольшой программы считается, что ее разработка включает задачи двух типов: проектирование и тестирование. При этом на этапе проектирования составляются некоторые виды тестов, которые неизбежно возникают на этом этапе. Остальные виды тестов касаются готового программного обеспечения.

ис1ерп-и&г(0^ее (ЯесЯиро4аНие Не&ормофЛо..

Жизненным циклом программного продукта принято называть время от первого появления идеи о создании данного продукта до его ухода из эксплуатации. В настоящее время в связи с созданием больших программных систем большими группами разработчиков, внедрением этих систем в другие области человеческой деятельности, то есть в связи с их долгой эксплуатацией пользователями, принято выделять пять основных этапов жизненного цикла программного продукта. Они описываются так, как будто строго следуют один за другим - один заканчивается и начинается другой. На самом деле они в значительной степени перекрываются. Перечислим эти этапы:

1. Планирование.

2. Проектирование.

3. Кодирование и написание документации.

4. Тестирование и исправление недостатков.

5. Сопровождение (после выпуска) и усовершенствование.

Рассмотрим относительную стоимость каждого из этих этапов:

Этапы1 стадии разработки:

1. Анализ требований 3%

2. Спецификация 3%

3. Проектирование 5%

4. Кодирование 7%

5. Тестирование 15%

Производственная стадия:

Промышленное производство

и сопровождение 67%.

Как видно их этих данных, дороже всего обходится сопровождение продукта после его выпуска. На втором месте по стоимости стоит тестирование - 45% от всей стоимости разработки. В процессе сопровождения продукта при исправлении ошибок и внесении усовершенствований в него большая часть затрат также приходится на тестирование. Продукт тестируют и исправляют практически на каждом этапе его жизненного цикла. При этом, чем дальше продвигается работа, тем дороже становятся и тестирование, и исправление ошибок.
10048 знаков